--- !ruby/object:RI::MethodDescription 
aliases: []

block_params: c
comment: 
- !ruby/struct:SM::Flow::P 
  body: "EventMachine's file monitoring API. Currently supported are the following events on individual files, using inotify on Linux systems, and kqueue for *BSD and Mac OS X:"
- !ruby/object:SM::Flow::LIST 
  contents: 
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: File modified (written to)
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: File moved/renamed
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: File deleted
  type: :BULLET
- !ruby/struct:SM::Flow::P 
  body: "EventMachine::watch_file takes a filename and a handler Module containing your custom callback methods. This will setup the low level monitoring on the specified file, and create a new EventMachine::FileWatch object with your Module mixed in. FileWatch is a subclass of {EventMachine::Connection}, so callbacks on this object work in the familiar way. The callbacks that will be fired by EventMachine are:"
- !ruby/object:SM::Flow::LIST 
  contents: 
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: file_modified
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: file_moved
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: file_deleted
  type: :BULLET
- !ruby/struct:SM::Flow::P 
  body: You can access the filename being monitored from within this object using {FileWatch#path}.
- !ruby/struct:SM::Flow::P 
  body: When a file is deleted, {FileWatch#stop_watching} will be called after your file_deleted callback, to clean up the underlying monitoring and remove EventMachine's reference to the now-useless {FileWatch} instance. This will in turn call unbind, if you wish to use it.
- !ruby/struct:SM::Flow::P 
  body: The corresponding system-level Errno will be raised when attempting to monitor non-existent files, files with wrong permissions, or if an error occurs dealing with inotify/kqueue.
- !ruby/struct:SM::Flow::P 
  body: "@example"
- !ruby/struct:SM::Flow::VERB 
  body: " # Before running this example, make sure we have a file to monitor:\n # $ echo &quot;bar&quot; &gt; /tmp/foo\n\n module Handler\n   def file_modified\n     puts &quot;#{path} modified&quot;\n   end\n\n   def file_moved\n     puts &quot;#{path} moved&quot;\n   end\n\n   def file_deleted\n     puts &quot;#{path} deleted&quot;\n   end\n\n   def unbind\n     puts &quot;#{path} monitoring ceased&quot;\n   end\n end\n\n # for efficient file watching, use kqueue on Mac OS X\n EventMachine.kqueue = true if EventMachine.kqueue?\n\n EventMachine.run {\n   EventMachine.watch_file(&quot;/tmp/foo&quot;, Handler)\n }\n\n # $ echo &quot;baz&quot; &gt;&gt; /tmp/foo    =&gt;    &quot;/tmp/foo modified&quot;\n # $ mv /tmp/foo /tmp/oof      =&gt;    &quot;/tmp/foo moved&quot;\n # $ rm /tmp/oof               =&gt;    &quot;/tmp/foo deleted&quot;\n"
- !ruby/struct:SM::Flow::P 
  body: "@note The ability to pick up on the new filename after a rename is not yet supported."
- !ruby/struct:SM::Flow::VERB 
  body: "      Calling #path will always return the filename you originally used.\n"
- !ruby/struct:SM::Flow::P 
  body: "@param [String] filename Local path to the file to watch. @param [Class, Module] handler A class or module that implements event handlers associated with the file."
full_name: EventMachine::watch_file
is_singleton: true
name: watch_file
params: (filename, handler=nil, *args) {|c| ...}
visibility: public
